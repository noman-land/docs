---
title: Simple Secure Authentication
---

This protocol, abbreviated SSA, is a custom protocol offered as alternative to OpenID and OAuth2.
It's much simpler and more secure in the sense that you cannot do something wrong.

> If you wonder why OpenID/OAuth2 is so complex and how this protocol can be so simple, I recommend reading this article.
> It dives into history, which is often the root to the present day situation.

The protocol has four endpoints:

- `{base-url}/sign-in`
- `{base-url}/avatar`
- `{base-url}/userinfo`
- `{base-url}/sign-out`

The endpoints and parameters have been especially chosen to differ from OpenID/OAuth2 to avoid confusion.


The pure frontend flow
----------------------


Just redirect to `{base-url}/sign-in` to let the user sign-in/up.
Once authenticated, the user will be redirected back to the `Referer`, the website it comes from.

```mermaid
example.com --redirects to--> /sign-in
/sign-in --User signs in/up--> /sign-in
example.com <--redirects to-- /sign-in

example.com --GET--> /avatar
example.com <-- /avatar


example.com --redirects to--> /sign-out
/sign-out --User confirms--> /sign-out
example.com <--redirects to-- /sign-out
```

Now, the are a couple of interesting things in this flow.

First, the authentication state is kept by a cookie. In particular a cookie with the flags `HTTP-Only`, `Secure`, `Path=/avatar` and `Same-Site=None`.
Each of these flags is important to ensure proper security.

Likewise, the call to `/avatar` is  must send the cookie.

```js
const res = await fetch(`${base_url}/avatar`, {credentials: "include"})
```

Note that this requires special [request handling](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#requests_with_credentials) server-side in order to set the CORS correctly.

The avatar is a trimmed down version of the full user profile. It contains `sub`, the anonymized user ID, `nickname` and `picture` which is an url to the user portrait.

```json
{
    "sub": "an anonymous user id",
    "nickname": "John Doe",
    "picture": "absolute or data url to user portrait"
}
```

### Differences to OpenID

Unlike OpenID allowing global user IDs (the `sub`), the SSA protocol imposes the user ID to be "pseudonymous pairwise identifiers".
In other words, they must differ for each website/client requesting the profile. This is to ensure privacy and it also improves security.

Also, you cannot request a different scope with the avatar. It's meant to be what is used by default in frontends.

> Basically, front-ends are more vulnerable to code injection attacks and client malware.
> If you want more user information, it should be obtained from the back-end. 


The back-end flow
-----------------

    /sign-in?scope=avatar+email+phone+address+identity&callback=https...&state=...

    POST [callback-url]
    application/x-www-form-urlencoded
    url-encoded: ticket=...&state=...

    /userinfo
    Authorization: Bearer [ticket]

Note that the ticket is consumed upon usage.
You give a ticket, you receive the user profile in exchange, that's it.
The ticket cannot be used anymore afterwards.

*For security reasons, the `callback` URL must belong to the same domain as the `Referer`.*


> Note that unlike OpenID / OAuth2, there is no access token, no id token and no refresh token.
> After all, there is no API to protect and no reason to have "reusable" tokens.
>
> Also, the callback itself is a POST and not a GET.
> This improves security by avoiding having the ticket being exposed in the URL,
> since URLs tend to easely eavesdropped and manipulated.



Device flow
-----------

Native apps and "smart devices" behave differently that servers.
They cannot simply receive a redirect.
Some devices like TV screens might not even show a browser, yet desire to be authenticated.

For such cases, the device flow exists and works like the OAuth2 device flow.